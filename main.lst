   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	setupPWM
  12               	setupPWM:
  13               	.LFB0:
  14               		.file 1 "pwm.h"
   1:pwm.h         **** #include <avr/io.h>
   2:pwm.h         **** #include "cpu_def.h"
   3:pwm.h         **** 
   4:pwm.h         **** //Define PWM Channels
   5:pwm.h         **** #define CH_A 0
   6:pwm.h         **** #define CH_B 1
   7:pwm.h         **** 
   8:pwm.h         **** void setupPWM(void);
   9:pwm.h         **** void pwm(uint8_t channel, uint16_t onTime, uint16_t period);
  10:pwm.h         **** 
  11:pwm.h         **** //Initializing PWM
  12:pwm.h         **** void setupPWM(void){
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  13:pwm.h         **** 	OC1x_DDR |= (1 << OC1A_PIN) | (1 << OC1B_PIN);
  21               		.loc 1 13 0
  22 0000 84B1      		in r24,0x4
  23 0002 8660      		ori r24,lo8(6)
  24 0004 84B9      		out 0x4,r24
  14:pwm.h         **** 	TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1 << WGM11);	
  25               		.loc 1 14 0
  26 0006 82EA      		ldi r24,lo8(-94)
  27 0008 8093 8000 		sts 128,r24
  15:pwm.h         **** 	TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
  28               		.loc 1 15 0
  29 000c 8AE1      		ldi r24,lo8(26)
  30 000e 8093 8100 		sts 129,r24
  31               	/* epilogue start */
  16:pwm.h         **** }
  32               		.loc 1 16 0
  33 0012 0895      		ret
  34               		.cfi_endproc
  35               	.LFE0:
  37               	.global	pwm
  39               	pwm:
  40               	.LFB1:
  17:pwm.h         **** 
  18:pwm.h         **** //Set PWM of the selected channel
  19:pwm.h         **** void pwm(uint8_t channel, uint16_t onTime, uint16_t period){
  41               		.loc 1 19 0
  42               		.cfi_startproc
  43               	.LVL0:
  44               	/* prologue: function */
  45               	/* frame size = 0 */
  46               	/* stack size = 0 */
  47               	.L__stack_usage = 0
  20:pwm.h         **** 	ICR1 = period;
  48               		.loc 1 20 0
  49 0014 5093 8700 		sts 134+1,r21
  50 0018 4093 8600 		sts 134,r20
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
  51               		.loc 1 21 0
  52 001c 8130      		cpi r24,lo8(1)
  53 001e 01F4      		brne .L3
  54               		.loc 1 21 0 is_stmt 0 discriminator 1
  55 0020 7093 8B00 		sts 138+1,r23
  56 0024 6093 8A00 		sts 138,r22
  57 0028 0895      		ret
  58               	.L3:
  59               		.loc 1 21 0 discriminator 2
  60 002a 7093 8900 		sts 136+1,r23
  61 002e 6093 8800 		sts 136,r22
  62               	/* epilogue start */
  22:pwm.h         **** }...
  63               		.loc 1 22 0 is_stmt 1 discriminator 2
  64 0032 0895      		ret
  65               		.cfi_endproc
  66               	.LFE1:
  68               	.global	initUSART
  70               	initUSART:
  71               	.LFB2:
  72               		.file 2 "serial.h"
   1:serial.h      **** #define BAUD_RATE 9600
   2:serial.h      **** #define BAUD_VAL (F_CPU / (16 * BAUD_RATE) - 1)
   3:serial.h      **** 
   4:serial.h      **** #include <avr/io.h>
   5:serial.h      **** #include "cpu_def.h"
   6:serial.h      **** 
   7:serial.h      **** void initUSART(void);
   8:serial.h      **** uint8_t getCh(void);
   9:serial.h      **** void putCh(uint8_t data);
  10:serial.h      **** 
  11:serial.h      **** void initUSART(void){
  73               		.loc 2 11 0
  74               		.cfi_startproc
  75               	/* prologue: function */
  76               	/* frame size = 0 */
  77               	/* stack size = 0 */
  78               	.L__stack_usage = 0
  12:serial.h      ****    //Set Baud rate; ubrr_value = F_OSC/(16 x Baud_rate) - 1; e.g. 16e6/(9600*16) -1 = 103
  13:serial.h      **** 	UBRRL_REG = BAUD_VAL;
  79               		.loc 2 13 0
  80 0034 85EC      		ldi r24,lo8(-59)
  81 0036 8093 C400 		sts 196,r24
  14:serial.h      **** 	UBRRH_REG = (BAUD_VAL >> 8);
  82               		.loc 2 14 0
  83 003a 82E0      		ldi r24,lo8(2)
  84 003c 8093 C500 		sts 197,r24
  15:serial.h      **** 	UCSRC_REG |= (1 << UCSZ1_BIT) | (1 << UCSZ0_BIT);
  85               		.loc 2 15 0
  86 0040 E2EC      		ldi r30,lo8(-62)
  87 0042 F0E0      		ldi r31,0
  88 0044 8081      		ld r24,Z
  89 0046 8660      		ori r24,lo8(6)
  90 0048 8083      		st Z,r24
  16:serial.h      **** 
  17:serial.h      **** 	#ifdef ATMEGA_32A
  18:serial.h      **** 	UCSRC_REG |= (1 << URSEL_BIT);
  19:serial.h      **** 	#endif
  20:serial.h      **** 
  21:serial.h      **** 	//Enable The receiver and transmitter
  22:serial.h      **** 	UCSRB_REG = (1 << RXEN_BIT) | (1 << TXEN_BIT);
  91               		.loc 2 22 0
  92 004a 88E1      		ldi r24,lo8(24)
  93 004c 8093 C100 		sts 193,r24
  94               	/* epilogue start */
  23:serial.h      **** }
  95               		.loc 2 23 0
  96 0050 0895      		ret
  97               		.cfi_endproc
  98               	.LFE2:
 100               	.global	getCh
 102               	getCh:
 103               	.LFB3:
  24:serial.h      **** 
  25:serial.h      **** uint8_t getCh(void){
 104               		.loc 2 25 0
 105               		.cfi_startproc
 106               	/* prologue: function */
 107               	/* frame size = 0 */
 108               	/* stack size = 0 */
 109               	.L__stack_usage = 0
 110               	.L7:
  26:serial.h      **** 	while(!(UCSRA_REG & (1 << RXC_BIT)));
 111               		.loc 2 26 0 discriminator 1
 112 0052 8091 C000 		lds r24,192
 113 0056 87FF      		sbrs r24,7
 114 0058 00C0      		rjmp .L7
  27:serial.h      **** 	return UDR_REG;
 115               		.loc 2 27 0
 116 005a 8091 C600 		lds r24,198
 117               	/* epilogue start */
  28:serial.h      **** }
 118               		.loc 2 28 0
 119 005e 0895      		ret
 120               		.cfi_endproc
 121               	.LFE3:
 123               	.global	putCh
 125               	putCh:
 126               	.LFB4:
  29:serial.h      **** 
  30:serial.h      **** void putCh(uint8_t data){
 127               		.loc 2 30 0
 128               		.cfi_startproc
 129               	/* prologue: function */
 130               	/* frame size = 0 */
 131               	/* stack size = 0 */
 132               	.L__stack_usage = 0
 133               	.LVL1:
 134               	.L10:
  31:serial.h      **** 	while(!(UCSRA_REG & (1 << UDRE_BIT)));
 135               		.loc 2 31 0 discriminator 1
 136 0060 9091 C000 		lds r25,192
 137 0064 95FF      		sbrs r25,5
 138 0066 00C0      		rjmp .L10
  32:serial.h      **** 	UDR_REG = data;
 139               		.loc 2 32 0
 140 0068 8093 C600 		sts 198,r24
 141               	/* epilogue start */
  33:serial.h      **** }...
 142               		.loc 2 33 0
 143 006c 0895      		ret
 144               		.cfi_endproc
 145               	.LFE4:
 147               	.global	begin
 149               	begin:
 150               	.LFB5:
 151               		.file 3 "software_serial.h"
   1:software_serial.h **** // Expressed as 4-cycle delays (must never be 0!)
   2:software_serial.h **** uint16_t _rx_delay_centering;
   3:software_serial.h **** uint16_t _rx_delay_intrabit;
   4:software_serial.h **** uint16_t _rx_delay_stopbit;
   5:software_serial.h **** uint16_t _tx_delay;
   6:software_serial.h **** 
   7:software_serial.h **** void begin(long speed){
 152               		.loc 3 7 0
 153               		.cfi_startproc
 154               	.LVL2:
 155               	/* prologue: function */
 156               	/* frame size = 0 */
 157               	/* stack size = 0 */
 158               	.L__stack_usage = 0
   8:software_serial.h **** 	_rx_delay_centering = _rx_delay_intrabit = _rx_delay_stopbit = _tx_delay = 0;
 159               		.loc 3 8 0
 160 006e 1092 0000 		sts _tx_delay+1,__zero_reg__
 161 0072 1092 0000 		sts _tx_delay,__zero_reg__
 162 0076 1092 0000 		sts _rx_delay_stopbit+1,__zero_reg__
 163 007a 1092 0000 		sts _rx_delay_stopbit,__zero_reg__
 164 007e 1092 0000 		sts _rx_delay_intrabit+1,__zero_reg__
 165 0082 1092 0000 		sts _rx_delay_intrabit,__zero_reg__
 166 0086 1092 0000 		sts _rx_delay_centering+1,__zero_reg__
 167 008a 1092 0000 		sts _rx_delay_centering,__zero_reg__
 168               	.LVL3:
 169               	/* epilogue start */
   9:software_serial.h **** 
  10:software_serial.h **** 	uint16_t bit_delay = (F_CPU / speed) / 4;
  11:software_serial.h **** }...
 170               		.loc 3 11 0
 171 008e 0895      		ret
 172               		.cfi_endproc
 173               	.LFE5:
 175               	.global	controlMotor
 177               	controlMotor:
 178               	.LFB7:
 179               		.file 4 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** 
   3:main.c        **** #define UP 		0x00
   4:main.c        **** #define DOWN	0x01
   5:main.c        **** #define RIGHT	0x02
   6:main.c        **** #define LEFT	0x03
   7:main.c        **** 
   8:main.c        **** #define MOTOR_DDR	DDRC
   9:main.c        **** #define MOTOR_PORT	PORTC
  10:main.c        **** 
  11:main.c        **** #define FORWARD_MODE() (MOTOR_PORT = 0x05)
  12:main.c        **** #define REVERSE_MODE() (MOTOR_PORT = 0x0A)
  13:main.c        **** 
  14:main.c        **** #define MAX_PWM_SPEED	20000
  15:main.c        **** #define MIN_PWM_SPEED	1000
  16:main.c        **** 
  17:main.c        **** #define FORWARD	0x04
  18:main.c        **** #define REVERSE	0x05
  19:main.c        **** 
  20:main.c        **** //Comment the MCU which you're not using.
  21:main.c        **** #define ATMEGA_328P
  22:main.c        **** //#define ATMEGA_32A
  23:main.c        **** 
  24:main.c        **** #include <avr/io.h>
  25:main.c        **** #include "pwm.h"
  26:main.c        **** #include "serial.h"
  27:main.c        **** #include "software_serial.h"
  28:main.c        **** 
  29:main.c        **** void controlMotor(uint8_t status);
  30:main.c        **** 
  31:main.c        **** uint16_t channelA = 0, channelB = 0;
  32:main.c        **** uint8_t channelA_status = FORWARD, channelB_status = FORWARD;
  33:main.c        **** 
  34:main.c        **** int main(void){
  35:main.c        **** 
  36:main.c        **** 	setupPWM();
  37:main.c        **** 	initUSART();
  38:main.c        **** 
  39:main.c        **** 	MOTOR_DDR = 0x0F;
  40:main.c        **** 
  41:main.c        **** 	pwm(CH_A, 0, MAX_PWM_SPEED);
  42:main.c        **** 	pwm(CH_B, 0, MAX_PWM_SPEED);
  43:main.c        **** 
  44:main.c        **** 	while(1){
  45:main.c        **** 		uint8_t input = getCh();
  46:main.c        **** 
  47:main.c        **** 		if(input == 'u')
  48:main.c        **** 			controlMotor(FORWARD);
  49:main.c        **** 		else if(input == 'd')
  50:main.c        **** 			controlMotor(REVERSE);
  51:main.c        **** 	}
  52:main.c        **** 	
  53:main.c        **** 	return 0;
  54:main.c        **** }
  55:main.c        **** 
  56:main.c        **** void controlMotor(uint8_t status){
 180               		.loc 4 56 0
 181               		.cfi_startproc
 182               	.LVL4:
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
 187 0090 2091 0000 		lds r18,channelA
 188 0094 3091 0000 		lds r19,channelA+1
  57:main.c        **** 	switch(status){
 189               		.loc 4 57 0
 190 0098 8430      		cpi r24,lo8(4)
 191 009a 01F0      		breq .L16
 192 009c 8530      		cpi r24,lo8(5)
 193 009e 01F4      		brne .+2
 194 00a0 00C0      		rjmp .L17
 195               	.LVL5:
 196               	.L15:
  58:main.c        **** 		case FORWARD:
  59:main.c        **** 			if(channelA_status == FORWARD && channelB_status == FORWARD){
  60:main.c        **** 				(channelA == MAX_PWM_SPEED) ? (channelA = MAX_PWM_SPEED) : (channelA += 100);
  61:main.c        **** 				channelB = channelA;
  62:main.c        **** 			}else if(channelA_status == REVERSE && channelB_status == REVERSE){
  63:main.c        **** 				if(channelA > MIN_PWM_SPEED){
  64:main.c        **** 					channelA -= 300;
  65:main.c        **** 					channelB = channelA;
  66:main.c        **** 				}else{
  67:main.c        **** 					FORWARD_MODE();
  68:main.c        **** 					channelA_status = FORWARD;
  69:main.c        **** 					channelB_status = FORWARD;
  70:main.c        **** 				}
  71:main.c        **** 			}
  72:main.c        **** 			break;
  73:main.c        **** 		case REVERSE:
  74:main.c        **** 			if(channelA_status == REVERSE && channelB_status == REVERSE){
  75:main.c        **** 				(channelA == MAX_PWM_SPEED) ? (channelA = MAX_PWM_SPEED) : (channelA += 100);
  76:main.c        **** 				channelB = channelA;
  77:main.c        **** 			}else if(channelA_status == FORWARD && channelB_status == FORWARD){
  78:main.c        **** 				if(channelA > MIN_PWM_SPEED){
  79:main.c        **** 					channelA -= 300;
  80:main.c        **** 					channelB = channelA;
  81:main.c        **** 				}else{
  82:main.c        **** 					REVERSE_MODE();
  83:main.c        **** 					channelA_status = REVERSE;
  84:main.c        **** 					channelB_status = REVERSE;
  85:main.c        **** 				}
  86:main.c        **** 			}
  87:main.c        **** 			break;
  88:main.c        **** 	}
  89:main.c        **** 
  90:main.c        **** 	pwm(CH_A, channelA, MAX_PWM_SPEED);
 197               		.loc 4 90 0
 198 00a2 2091 0000 		lds r18,channelA
 199 00a6 3091 0000 		lds r19,channelA+1
 200               	.LVL6:
 201               	.LBB11:
 202               	.LBB12:
  20:pwm.h         **** 	ICR1 = period;
 203               		.loc 1 20 0
 204 00aa 80E2      		ldi r24,lo8(32)
 205 00ac 9EE4      		ldi r25,lo8(78)
 206 00ae 9093 8700 		sts 134+1,r25
 207 00b2 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 208               		.loc 1 21 0
 209 00b6 3093 8900 		sts 136+1,r19
 210 00ba 2093 8800 		sts 136,r18
 211               	.LVL7:
 212               	.LBE12:
 213               	.LBE11:
  91:main.c        **** 	pwm(CH_B, channelB, MAX_PWM_SPEED);
 214               		.loc 4 91 0
 215 00be 2091 0000 		lds r18,channelB
 216 00c2 3091 0000 		lds r19,channelB+1
 217               	.LVL8:
 218               	.LBB13:
 219               	.LBB14:
  20:pwm.h         **** 	ICR1 = period;
 220               		.loc 1 20 0
 221 00c6 9093 8700 		sts 134+1,r25
 222 00ca 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 223               		.loc 1 21 0
 224 00ce 3093 8B00 		sts 138+1,r19
 225 00d2 2093 8A00 		sts 138,r18
 226               	.LVL9:
 227               	/* epilogue start */
 228               	.LBE14:
 229               	.LBE13:
  92:main.c        **** }...
 230               		.loc 4 92 0
 231 00d6 0895      		ret
 232               	.LVL10:
 233               	.L16:
  59:main.c        **** 			if(channelA_status == FORWARD && channelB_status == FORWARD){
 234               		.loc 4 59 0
 235 00d8 9091 0000 		lds r25,channelA_status
 236 00dc 9430      		cpi r25,lo8(4)
 237 00de 01F4      		brne .L18
  59:main.c        **** 			if(channelA_status == FORWARD && channelB_status == FORWARD){
 238               		.loc 4 59 0 is_stmt 0 discriminator 1
 239 00e0 8091 0000 		lds r24,channelB_status
 240               	.LVL11:
 241 00e4 8430      		cpi r24,lo8(4)
 242 00e6 01F4      		brne .L15
  60:main.c        **** 				(channelA == MAX_PWM_SPEED) ? (channelA = MAX_PWM_SPEED) : (channelA += 100);
 243               		.loc 4 60 0 is_stmt 1
 244 00e8 2032      		cpi r18,32
 245 00ea 4EE4      		ldi r20,78
 246 00ec 3407      		cpc r19,r20
 247 00ee 01F0      		breq .L22
 248               	.L32:
  75:main.c        **** 				(channelA == MAX_PWM_SPEED) ? (channelA = MAX_PWM_SPEED) : (channelA += 100);
 249               		.loc 4 75 0 discriminator 2
 250 00f0 2C59      		subi r18,-100
 251 00f2 3F4F      		sbci r19,-1
 252 00f4 3093 0000 		sts channelA+1,r19
 253 00f8 2093 0000 		sts channelA,r18
 254 00fc 00C0      		rjmp .L22
 255               	.LVL12:
 256               	.L18:
  62:main.c        **** 			}else if(channelA_status == REVERSE && channelB_status == REVERSE){
 257               		.loc 4 62 0
 258 00fe 9530      		cpi r25,lo8(5)
 259 0100 01F4      		brne .L15
  62:main.c        **** 			}else if(channelA_status == REVERSE && channelB_status == REVERSE){
 260               		.loc 4 62 0 is_stmt 0 discriminator 1
 261 0102 9091 0000 		lds r25,channelB_status
 262 0106 9530      		cpi r25,lo8(5)
 263 0108 01F4      		brne .L15
  63:main.c        **** 				if(channelA > MIN_PWM_SPEED){
 264               		.loc 4 63 0 is_stmt 1
 265 010a 293E      		cpi r18,-23
 266 010c 43E0      		ldi r20,3
 267 010e 3407      		cpc r19,r20
 268 0110 00F0      		brlo .L31
 269               	.L30:
  79:main.c        **** 					channelA -= 300;
 270               		.loc 4 79 0
 271 0112 2C52      		subi r18,44
 272 0114 3140      		sbci r19,1
 273 0116 3093 0000 		sts channelA+1,r19
 274 011a 2093 0000 		sts channelA,r18
  80:main.c        **** 					channelB = channelA;
 275               		.loc 4 80 0
 276 011e 3093 0000 		sts channelB+1,r19
 277 0122 2093 0000 		sts channelB,r18
 278 0126 00C0      		rjmp .L15
 279               	.L17:
  74:main.c        **** 			if(channelA_status == REVERSE && channelB_status == REVERSE){
 280               		.loc 4 74 0
 281 0128 9091 0000 		lds r25,channelA_status
 282 012c 9530      		cpi r25,lo8(5)
 283 012e 01F4      		brne .L21
  74:main.c        **** 			if(channelA_status == REVERSE && channelB_status == REVERSE){
 284               		.loc 4 74 0 is_stmt 0 discriminator 1
 285 0130 8091 0000 		lds r24,channelB_status
 286               	.LVL13:
 287 0134 8530      		cpi r24,lo8(5)
 288 0136 01F0      		breq .+2
 289 0138 00C0      		rjmp .L15
  75:main.c        **** 				(channelA == MAX_PWM_SPEED) ? (channelA = MAX_PWM_SPEED) : (channelA += 100);
 290               		.loc 4 75 0 is_stmt 1
 291 013a 2032      		cpi r18,32
 292 013c 8EE4      		ldi r24,78
 293 013e 3807      		cpc r19,r24
 294 0140 01F4      		brne .L32
 295               	.L22:
  76:main.c        **** 				channelB = channelA;
 296               		.loc 4 76 0
 297 0142 8091 0000 		lds r24,channelA
 298 0146 9091 0000 		lds r25,channelA+1
 299 014a 9093 0000 		sts channelB+1,r25
 300 014e 8093 0000 		sts channelB,r24
 301 0152 00C0      		rjmp .L15
 302               	.LVL14:
 303               	.L21:
  77:main.c        **** 			}else if(channelA_status == FORWARD && channelB_status == FORWARD){
 304               		.loc 4 77 0
 305 0154 9430      		cpi r25,lo8(4)
 306 0156 01F0      		breq .+2
 307 0158 00C0      		rjmp .L15
  77:main.c        **** 			}else if(channelA_status == FORWARD && channelB_status == FORWARD){
 308               		.loc 4 77 0 is_stmt 0 discriminator 1
 309 015a 9091 0000 		lds r25,channelB_status
 310 015e 9430      		cpi r25,lo8(4)
 311 0160 01F0      		breq .+2
 312 0162 00C0      		rjmp .L15
  78:main.c        **** 				if(channelA > MIN_PWM_SPEED){
 313               		.loc 4 78 0 is_stmt 1
 314 0164 293E      		cpi r18,-23
 315 0166 93E0      		ldi r25,3
 316 0168 3907      		cpc r19,r25
 317 016a 00F4      		brsh .L30
  82:main.c        **** 					REVERSE_MODE();
 318               		.loc 4 82 0
 319 016c 9AE0      		ldi r25,lo8(10)
 320               	.L31:
 321 016e 98B9      		out 0x8,r25
  83:main.c        **** 					channelA_status = REVERSE;
 322               		.loc 4 83 0
 323 0170 8093 0000 		sts channelA_status,r24
  84:main.c        **** 					channelB_status = REVERSE;
 324               		.loc 4 84 0
 325 0174 8093 0000 		sts channelB_status,r24
 326 0178 00C0      		rjmp .L15
 327               		.cfi_endproc
 328               	.LFE7:
 330               		.section	.text.startup,"ax",@progbits
 331               	.global	main
 333               	main:
 334               	.LFB6:
  34:main.c        **** int main(void){
 335               		.loc 4 34 0
 336               		.cfi_startproc
 337               	/* prologue: function */
 338               	/* frame size = 0 */
 339               	/* stack size = 0 */
 340               	.L__stack_usage = 0
  36:main.c        **** 	setupPWM();
 341               		.loc 4 36 0
 342 0000 0E94 0000 		call setupPWM
 343               	.LVL15:
  37:main.c        **** 	initUSART();
 344               		.loc 4 37 0
 345 0004 0E94 0000 		call initUSART
 346               	.LVL16:
  39:main.c        **** 	MOTOR_DDR = 0x0F;
 347               		.loc 4 39 0
 348 0008 8FE0      		ldi r24,lo8(15)
 349 000a 87B9      		out 0x7,r24
 350               	.LVL17:
 351               	.LBB15:
 352               	.LBB16:
  20:pwm.h         **** 	ICR1 = period;
 353               		.loc 1 20 0
 354 000c 80E2      		ldi r24,lo8(32)
 355 000e 9EE4      		ldi r25,lo8(78)
 356 0010 9093 8700 		sts 134+1,r25
 357 0014 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 358               		.loc 1 21 0
 359 0018 1092 8900 		sts 136+1,__zero_reg__
 360 001c 1092 8800 		sts 136,__zero_reg__
 361               	.LVL18:
 362               	.LBE16:
 363               	.LBE15:
 364               	.LBB17:
 365               	.LBB18:
  20:pwm.h         **** 	ICR1 = period;
 366               		.loc 1 20 0
 367 0020 9093 8700 		sts 134+1,r25
 368 0024 8093 8600 		sts 134,r24
  21:pwm.h         **** 	(channel == CH_B) ? (OCR1B = onTime) : (OCR1A = onTime);
 369               		.loc 1 21 0
 370 0028 1092 8B00 		sts 138+1,__zero_reg__
 371 002c 1092 8A00 		sts 138,__zero_reg__
 372               	.L34:
 373               	.LBE18:
 374               	.LBE17:
 375               	.LBB19:
  45:main.c        **** 		uint8_t input = getCh();
 376               		.loc 4 45 0
 377 0030 0E94 0000 		call getCh
 378               	.LVL19:
  47:main.c        **** 		if(input == 'u')
 379               		.loc 4 47 0
 380 0034 8537      		cpi r24,lo8(117)
 381 0036 01F4      		brne .L35
  48:main.c        **** 			controlMotor(FORWARD);
 382               		.loc 4 48 0
 383 0038 84E0      		ldi r24,lo8(4)
 384               	.LVL20:
 385               	.L37:
  50:main.c        **** 			controlMotor(REVERSE);
 386               		.loc 4 50 0
 387 003a 0E94 0000 		call controlMotor
 388               	.LVL21:
 389 003e 00C0      		rjmp .L34
 390               	.LVL22:
 391               	.L35:
  49:main.c        **** 		else if(input == 'd')
 392               		.loc 4 49 0
 393 0040 8436      		cpi r24,lo8(100)
 394 0042 01F4      		brne .L34
  50:main.c        **** 			controlMotor(REVERSE);
 395               		.loc 4 50 0
 396 0044 85E0      		ldi r24,lo8(5)
 397               	.LVL23:
 398 0046 00C0      		rjmp .L37
 399               	.LBE19:
 400               		.cfi_endproc
 401               	.LFE6:
 403               	.global	channelB_status
 404               		.data
 407               	channelB_status:
 408 0000 04        		.byte	4
 409               	.global	channelA_status
 412               	channelA_status:
 413 0001 04        		.byte	4
 414               	.global	channelB
 415               		.section .bss
 418               	channelB:
 419 0000 0000      		.zero	2
 420               	.global	channelA
 423               	channelA:
 424 0002 0000      		.zero	2
 425               		.comm	_tx_delay,2,1
 426               		.comm	_rx_delay_stopbit,2,1
 427               		.comm	_rx_delay_intrabit,2,1
 428               		.comm	_rx_delay_centering,2,1
 429               		.text
 430               	.Letext0:
 431               		.file 5 "/usr/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc4FAS5C.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc4FAS5C.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc4FAS5C.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc4FAS5C.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc4FAS5C.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc4FAS5C.s:12     .text:0000000000000000 setupPWM
     /tmp/cc4FAS5C.s:39     .text:0000000000000014 pwm
     /tmp/cc4FAS5C.s:70     .text:0000000000000034 initUSART
     /tmp/cc4FAS5C.s:102    .text:0000000000000052 getCh
     /tmp/cc4FAS5C.s:125    .text:0000000000000060 putCh
     /tmp/cc4FAS5C.s:149    .text:000000000000006e begin
                            *COM*:0000000000000002 _tx_delay
                            *COM*:0000000000000002 _rx_delay_stopbit
                            *COM*:0000000000000002 _rx_delay_intrabit
                            *COM*:0000000000000002 _rx_delay_centering
     /tmp/cc4FAS5C.s:177    .text:0000000000000090 controlMotor
     /tmp/cc4FAS5C.s:423    .bss:0000000000000002 channelA
     /tmp/cc4FAS5C.s:418    .bss:0000000000000000 channelB
     /tmp/cc4FAS5C.s:412    .data:0000000000000001 channelA_status
     /tmp/cc4FAS5C.s:407    .data:0000000000000000 channelB_status
     /tmp/cc4FAS5C.s:333    .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
